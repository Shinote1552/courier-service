// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"context"
	"github.com/avito-tech/go-transaction-manager/pgxv5"
	"github.com/jackc/pgx/v5/pgxpool"
	"google.golang.org/grpc"
	order2 "service/internal/gateway/grpc/order"
	"service/internal/generated/proto/clients"
	"service/internal/handlers/rest/courier_get"
	"service/internal/handlers/rest/courier_post"
	"service/internal/handlers/rest/courier_put"
	"service/internal/handlers/rest/couriers_get"
	"service/internal/handlers/rest/delivery_assign_post"
	"service/internal/handlers/rest/delivery_unassign_post"
	"service/internal/handlers/tasks/delivery_cleanup"
	"service/internal/pkg/config"
	"service/internal/pkg/factory/delivery_deadline"
	"service/internal/pkg/factory/order_handle"
	"service/internal/repository/courier"
	"service/internal/repository/delivery"
	courier2 "service/internal/service/courier"
	delivery2 "service/internal/service/delivery"
	"service/internal/service/order"
	"service/pkg/background"
	"service/pkg/logger"
	"service/pkg/querier"
	"service/pkg/tx"
	"time"
)

// Injectors from wire.go:

// InitializeApplication для HTTP сервиса (cmd/service)
func InitializeApplication(ctx context.Context, log logger.Logger, pool *pgxpool.Pool, getter *pgxv5.CtxGetter, conn *grpc.ClientConn, cfg *config.Config) (*Application, error) {
	querier := provideQuerier(pool, getter)
	repository := provideCourierRepository(querier)
	manager := provideTxManager(pool)
	courier := provideServiceCourier(repository, manager)
	deliveryRepository := provideDeliveryRepository(querier)
	deliveryTimeFactory := delivery_deadline.New()
	delivery := provideServiceDelivery(deliveryRepository, courier, deliveryTimeFactory, manager)
	cleanupInterval := provideCleanupInterval(cfg)
	deliveryCleanup := provideDeliveryCleanupTask(log, delivery, cleanupInterval)
	v := provideTaskList(deliveryCleanup)
	worker, err := provideBackgroundWorkers(ctx, log, v)
	if err != nil {
		return nil, err
	}
	application := &Application{
		ServiceCourier:    courier,
		ServiceDelivery:   delivery,
		BackgroundWorkers: worker,
	}
	return application, nil
}

// InitializeKafkaWorkerApp для Kafka воркера (cmd/worker-order-status-changed)
func InitializeKafkaWorkerApp(ctx context.Context, log logger.Logger, pool *pgxpool.Pool, getter *pgxv5.CtxGetter, conn *grpc.ClientConn, cfg *config.Config) (*KafkaWorkerApp, error) {
	ordersServiceClient := provideOrderServiceClient(conn)
	orderGateway := provideOrderGateway(ordersServiceClient)
	querier := provideQuerier(pool, getter)
	repository := provideDeliveryRepository(querier)
	courierRepository := provideCourierRepository(querier)
	manager := provideTxManager(pool)
	courier := provideServiceCourier(courierRepository, manager)
	deliveryTimeFactory := delivery_deadline.New()
	delivery := provideServiceDelivery(repository, courier, deliveryTimeFactory, manager)
	statusHandlerFactory := provideStatusHandlerFabric(delivery)
	service := provideOrderService(orderGateway, delivery, statusHandlerFactory)
	kafkaWorkerApp := &KafkaWorkerApp{
		OrderService: service,
	}
	return kafkaWorkerApp, nil
}

// wire.go:

type (
	CleanupInterval time.Duration
)

type Application struct {
	ServiceCourier    ServiceCourier
	ServiceDelivery   ServiceDelivery
	BackgroundWorkers *background.Worker
}

type ServiceCourier interface {
	courier_get.Service
	courier_post.Service
	courier_put.Service
	couriers_get.Service
}

type ServiceDelivery interface {
	delivery_assign_post.Service
	delivery_unassign_post.Service
}

type KafkaWorkerApp struct {
	OrderService *order.Service
}

func provideTxManager(pool *pgxpool.Pool) *tx.Manager {
	return tx.New(pool)
}

func provideQuerier(pool *pgxpool.Pool, getter *pgxv5.CtxGetter) *querier.Querier {
	return querier.New(pool, getter)
}

func provideCourierRepository(querier2 *querier.Querier) *courier.Repository {
	return courier.New(querier2)
}

func provideDeliveryRepository(querier2 *querier.Querier) *delivery.Repository {
	return delivery.New(querier2)
}

func provideServiceCourier(
	repository courier2.Repository,
	txManager courier2.TxManager,
) *courier2.Courier {
	return courier2.New(repository, txManager)
}

func provideServiceDelivery(
	repository delivery2.Repository,
	courierService delivery2.CourierService,
	timeFactory delivery2.DeliveryTimeFactory,
	txManager delivery2.TxManager,
) *delivery2.Delivery {
	return delivery2.New(
		repository,
		courierService,
		timeFactory,
		txManager,
	)
}

func provideCleanupInterval(cfg *config.Config) CleanupInterval {
	return CleanupInterval(cfg.Tasks.CouriersStatusUpdateInterval)
}

func provideOrderServiceClient(conn *grpc.ClientConn) orders.OrdersServiceClient {
	return orders.NewOrdersServiceClient(conn)
}

func provideOrderGateway(client orders.OrdersServiceClient) *order2.OrderGateway {
	return order2.New(client)
}

// provideOrderService создает orderService для обработки событий Kafka
func provideOrderService(
	orderGateway *order2.OrderGateway,
	deliveryService *delivery2.Delivery,
	handlerFactory order.HandlerFactory,
) *order.Service {
	return order.New(orderGateway, deliveryService, handlerFactory)
}

func provideStatusHandlerFabric(deliveryService *delivery2.Delivery) *order_handle.StatusHandlerFactory {
	return order_handle.NewStatusHandlerFactory(deliveryService)
}

func provideDeliveryCleanupTask(
	log logger.Logger,
	deliveryService delivery_cleanup.Service,
	interval CleanupInterval,
) *delivery_cleanup.DeliveryCleanup {
	return delivery_cleanup.NewDeliveryCleanup(log, deliveryService, time.Duration(interval))
}

func provideTaskList(
	deliveryCleanupTask *delivery_cleanup.DeliveryCleanup,
) []background.Task {
	return []background.Task{
		deliveryCleanupTask,
	}
}

func provideBackgroundWorkers(ctx context.Context, log logger.Logger, tasks []background.Task) (*background.Worker, error) {
	return background.New(ctx, log, tasks)
}
