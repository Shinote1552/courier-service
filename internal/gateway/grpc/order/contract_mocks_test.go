// Code generated by MockGen. DO NOT EDIT.
// Source: contract.go
//
// Generated by this command:
//
//	mockgen -source=contract.go -destination=./contract_mocks_test.go -package=order_test
//

// Package order_test is a generated GoMock package.
package order_test

import (
	context "context"
	reflect "reflect"
	orders "service/internal/generated/proto/clients"

	gomock "go.uber.org/mock/gomock"
	grpc "google.golang.org/grpc"
)

// Mockclient is a mock of client interface.
type Mockclient struct {
	ctrl     *gomock.Controller
	recorder *MockclientMockRecorder
	isgomock struct{}
}

// MockclientMockRecorder is the mock recorder for Mockclient.
type MockclientMockRecorder struct {
	mock *Mockclient
}

// NewMockclient creates a new mock instance.
func NewMockclient(ctrl *gomock.Controller) *Mockclient {
	mock := &Mockclient{ctrl: ctrl}
	mock.recorder = &MockclientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockclient) EXPECT() *MockclientMockRecorder {
	return m.recorder
}

// GetOrderById mocks base method.
func (m *Mockclient) GetOrderById(ctx context.Context, in *orders.GetOrderByIdRequest, opts ...grpc.CallOption) (*orders.GetOrderByIdResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetOrderById", varargs...)
	ret0, _ := ret[0].(*orders.GetOrderByIdResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrderById indicates an expected call of GetOrderById.
func (mr *MockclientMockRecorder) GetOrderById(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrderById", reflect.TypeOf((*Mockclient)(nil).GetOrderById), varargs...)
}

// GetOrders mocks base method.
func (m *Mockclient) GetOrders(ctx context.Context, in *orders.GetOrdersRequest, opts ...grpc.CallOption) (*orders.GetOrdersResponse, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetOrders", varargs...)
	ret0, _ := ret[0].(*orders.GetOrdersResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrders indicates an expected call of GetOrders.
func (mr *MockclientMockRecorder) GetOrders(ctx, in any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrders", reflect.TypeOf((*Mockclient)(nil).GetOrders), varargs...)
}

// Mockretrier is a mock of retrier interface.
type Mockretrier struct {
	ctrl     *gomock.Controller
	recorder *MockretrierMockRecorder
	isgomock struct{}
}

// MockretrierMockRecorder is the mock recorder for Mockretrier.
type MockretrierMockRecorder struct {
	mock *Mockretrier
}

// NewMockretrier creates a new mock instance.
func NewMockretrier(ctrl *gomock.Controller) *Mockretrier {
	mock := &Mockretrier{ctrl: ctrl}
	mock.recorder = &MockretrierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockretrier) EXPECT() *MockretrierMockRecorder {
	return m.recorder
}

// ExecuteWithContext mocks base method.
func (m *Mockretrier) ExecuteWithContext(ctx context.Context, fn func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteWithContext", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteWithContext indicates an expected call of ExecuteWithContext.
func (mr *MockretrierMockRecorder) ExecuteWithContext(ctx, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteWithContext", reflect.TypeOf((*Mockretrier)(nil).ExecuteWithContext), ctx, fn)
}
